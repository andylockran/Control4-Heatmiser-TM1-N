<devicedata>
   <copyright>Copyright 2015 Andy Loughran.  All rights reserved.</copyright>
   <manufacturer>ZRMT</manufacturer>
   <creator>Andy Loughran</creator>
   <created>02/11/2015 20:00</created>
   <modified>02/11/2015 20:00</modified>
     <driver>DriverWorks</driver>
    <combo>true</combo>
   <name>Heatmiser-tm1</name>
   <model>TM1-N</model>
   <version>21</version>
   <proxy>zrmtheatmisertm1</proxy>
  <small>devices_sm/C4.gif</small>
  <large>devices_lg/C4.gif</large>
   <control>lua_gen</control>
   <front/><back/><top/><bottom/><left/><right/>
  <composer_categories />
  <capabilities />
  <connections />
  <config>
<script>
    <![CDATA[
HMV2_ID = 2
HMV3_ID = 3
BYTEMASK = 0xff
DONT_CARE_LENGTH = 1
-- Master must be in range [0x81,0xa0] = [129,160]
MASTER_ADDR_MIN = 0x81
MASTER_ADDR_MAX = 0xa0
-- Define magic numbers used in messages
FUNC_READ  = 0
FUNC_WRITE = 1
BROADCAST_ADDR = 0xff
RW_LENGTH_ALL = 0xffff
HOT_WATER_ADDR_VAL = 42

HOT_WATER_ON_VAL = 01
HOT_WATER_OFF_VAL = 00

MY_MASTER_ADDR = 0x81
g_SerialData = ""
function lsh(value,shift)
    return (value*(2^shift)) % 2^24
end
function rsh(value,shift)
    return math.floor(value/2^shift) % 2^24
end
function bitand(a, b)
    local result = 0
    local bitval = 1
    while a > 0 and b > 0 do
      if a % 2 == 1 and b % 2 == 1 then -- test the rightmost bits
          result = result + bitval      -- set the current bit
      end
      bitval = bitval * 2 -- shift left
      a = math.floor(a/2) -- shift right
      b = math.floor(b/2)
    end
    return result
end
function bitor(x, y)
  local p = 1
  while p < x do p = p + p end
  while p < y do p = p + p end
  local z = 0
  repeat
    if p <= x or p <= y then
      z = z + p
      if p <= x then x = x - p end
      if p <= y then y = y - p end
    end
    p = p * 0.5
  until p < 1
  return z
end
function xor(a,b)
  local r = 0
  local f = math.floor
  for i = 0, 31 do
    local x = a / 2 + b / 2
    if x ~= f(x) then
      r = r + 2^i
    end
    a = f(a / 2)
    b = f(b / 2)
  end
  return r
end

-- Andy starts coding here 

crc16 = {}
crc16.__index = crc16

function crc16.new(LookupHigh,LookupLow,High,Low)
  local o = {}
  o.LookupHigh = { 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x81, 0x91, 0xa1, 0xb1, 0xc1, 0xd1, 0xe1, 0xf1 }
  o.LookupLow = { 0x00, 0x21, 0x42, 0x63, 0x84, 0xa5, 0xc6, 0xe7, 0x08, 0x29, 0x4a, 0x6b, 0x8c, 0xad, 0xce, 0xef }
  o.High = 0xff
  o.Low = BYTEMASK
  setmetatable(o,crc16)
  return o
end

function crc16:Update4Bits(val)
  --Step one, extract the Most significant 4 bits of the CRC register
  --print(self.High)
  t = rsh(self.High,4)
  --print("t is: " .. t)
  
  --XOR in the Message Data into the extracted bits
  t = xor(t,val)  
  --print("t is now: " .. t)
  
  --Shift the CRC Register left 4 bits
  self.High = bitor(lsh(self.High,4),rsh(self.Low,4))
  --print(self.High)
  self.High = bitand(self.High,BYTEMASK)
  --print(self.High)
  self.Low = lsh(self.Low,4)
  --print(self.Low)
  self.Low = bitand(self.Low,BYTEMASK)
  --print(self.Low)

  --print("Low",self.Low)
  --print("High",self.High)

  --Do the table lookups and XOR the results into the CRC tables
  self.High = xor(self.High,self.LookupHigh[t+1])
  --print(self.High)
  self.High = bitand(self.High,BYTEMASK)
  --print (self.High)
  self.Low = xor(self.Low,self.LookupLow[t+1])
  --print(self.Low)
  self.Low = bitand(self.Low,BYTEMASK)
  --print(self.Low)
  
  --print("FLow:",self.Low)
  --print("FHigh:",self.High)


end

function crc16:CRC16_Update(val)
  --print("Value:",val)
  self:Update4Bits(rsh(val,4))
  self:Update4Bits(bitand(val,0x0f))
end

function crc16:run(message)
  -- Calculates a crc
  --print "Fuck off"
  print(message)
  --print(string.len(message))  
  for k,value in ipairs(message) do
    --print(v)
    self:CRC16_Update(value)
    --print(self.Low)
   -- print(self.High)
  end
  table.insert(msg,self.Low)
  table.insert(msg,self.High)
  return msg
end

-- Testing the functionality below:
--crc = crc16.new()
--andy = crc:run(1212121121212)
--print(andy[1],andy[2])

crc = crc16.new()


function hmFormMsg(destination,source,functioncall,start,payload)
  --print("hmFormMsg:            ",destination,source,functioncall,start,payload)
  start_low = bitand(start,BYTEMASK)
  start_high = bitand(rsh(start,8),BYTEMASK)
  payloadstring = tostring(payload)
  payloadLength = #payloadstring
  last_low = bitand(payloadLength,BYTEMASK)
  last_high = bitand(rsh(payloadLength,8),BYTEMASK)
  --print(destination,source,functioncall,start,payload)
  if functioncall == FUNC_READ then 
    print("Read")
    payloadLength = 0x00
    length_low = BMAnd(RW_LENGTH_ALL,BYTEMASK)
    length_high = BMAnd(rsh(RW_LENGTH_ALL,8),BYTEMASK)
    msg = {destination,10+payloadLength, source, functioncall, start_low, start_high, length_low, length_high}
    return msg
  end
  if functioncall == FUNC_WRITE then
    msg = {destination, 10+payloadLength, source, functioncall, start_low, start_high, last_low, last_high}
    table.insert(msg,payload)
    --print("destination:\t",msg[1],"\npayload:\t",msg[2],"\nsource:\t\t",msg[3],"\nfunction\t",msg[4],"\nsl\t\t",msg[5],"\nsh\t\t",msg[6],"\nfl\t\t",msg[7],"\nfh\t\t",msg[8])
    return msg
  end

end

function hmFormMsgCRC(destination, source, functioncall, start, payload)
  --Forms a message payload, including CRC"""
  --print("hmFormMsgCRC:         ", destination,source, functioncall, start, payload)
  data = hmFormMsg(destination, source, functioncall, start, payload)
  --print("Payload data: ", data)
  newdata = crc:run(data)
  --crc:run(data)
  return data
end

function hmVerifyMsgCRCOK(source, expectedFunction, expectedLength, datal)
  --print(datal)
  --expectedchecksum = crc:run(rxmsg)
  if expectedchecksum == checksum then
    print("CRC is correct")
  else
    print("Incorrect CRC")
  end
end

function ReceivedFromSerial(idBinding, strData)
  hexdump(strData)
end

function hmSendMsg(message)
  --print(message)
  data2 = {}
  for k,v in ipairs(message) do
    -- Need to insert the value as a chr value
    v = string.char(v)
    table.insert(data2,v)
  end
  C4:SendToSerial(1, table.concat(data2))
  print "data sent to serial"
  ReceivedFromSerial(1,strData)
  return 1
end

function hotWaterSwitch(destination,payload)
  --print("hotWaterSwitch: ",destination,MY_MASTER_ADDR,FUNC_WRITE,HOT_WATER_ADDR_VAL,payload)
  msg = hmFormMsgCRC(destination,MY_MASTER_ADDR,FUNC_WRITE,HOT_WATER_ADDR_VAL,payload)
  hmSendMsg(msg)
end

function OnPropertyChanged(strProperty)
  if (strProperty == 'State') then
    if (Properties[strProperty]=='SwitchOn') then
      print("Turning Hot Water On")
      hotWaterSwitch(Properties['ThermostatID'],HOT_WATER_ON_VAL)
      print("That is done")
    elseif (Properties[strProperty]=='SwitchOff') then
      print("Turning Hot Water to Auto")
      hotWaterSwitch(Properties['ThermostatID'],HOT_WATER_OFF_VAL)
    else
      print("Status is: ",Properties['State'],".  Contact andy")
    end
  else
    print("Status is: ",Properties['State'],".  Contact andy")
    print("Thermostat id:",Properties['ThermostatID'])
  end
end

--function LUA_ACTION.hotWaterOnPlease()
--  print("Hot water turning on")
--  hotWaterSwitch(Properties['ThermostatID'],HOT_WATER_ON_VAL)
--end

--function LUA_ACTION.hotWaterTimedPlease()
--  print("Hot water timed mode")
--  hotWaterSwitch(Properties['ThermostatID'],HOT_WATER_AUTO_VAL)
--end

--print(hotWaterSwitch("5,HOT_WATER_ON_VAL))
  
  ]]>
      </script>
       <properties>
    <property>      
        <name>ThermostatID</name>
          <type>RANGED_INTEGER</type>
          <minimum>0</minimum>
          <maximum>32</maximum>
      </property>
      <property>
        <name>State</name>
          <type>LIST</type>
          <items>
            <item>On</item>
            <item>SwitchOn</item>
            <item>Off</item>
            <item>SwitchOff</item>
          </items>
        <default>No</default>
        <readonly>false</readonly>
      </property>
  </properties>      
  
   </config>
</devicedata>
